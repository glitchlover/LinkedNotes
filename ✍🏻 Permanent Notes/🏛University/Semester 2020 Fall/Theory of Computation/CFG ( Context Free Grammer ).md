---
tags: null
cards-deck: Theory of Computation::CFG
---

# Context Free Language

A context language is a language generated by [[ðŸ”‘Context Free Grammar]]

---

## Definition #card

Context free grammar is a formal grammar which is used to generate all possible strings in a given formal language.
^1608042757319

---

The set "{}" of all CFL is identical to the set  "{}" of languages accepted by [[Pushdown Automata]]

---

### **Context Free Grammar** is defined by . . . #card

-   defined by 4 tuples as G = {V, â¨Š / T, P, S} where
    -   V = Set of  Variable or [[CFG ( Context Free Grammer )#^bc2370]] Symbol
    -   â¨Š / T  = Set of [[CFG ( Context Free Grammer )#^bc2370]]^1608393331212
 Symbol
    -   P = [[Production]] Symbol
    -   S = Start Symbol (a [[CFG ( Context Free Grammer )#^0c9bd3]])

---

#### Example

-   The grammar ({A}, {a, b, c}, P, A), P : A â†’ aA, A â†’ abc.
-   The grammar ({S, a, b}, {a, b}, P, S), P: S â†’ aSa, S â†’ bSb, S â†’ Îµ
-   The grammar ({S, F}, {0, 1}, P, S), P: S â†’ 00S | 11F, F â†’ 00F | Îµ

### Terminal Symbol #card
-   A terminal is a symbol which does not appear on the left-hand side of any production. ^bc2370
-   Terminal symbols cannot be changed using the rules of the grammar.
-   terminal symbols, which are the characters of the alphabet that appear in the strings generated by the grammar.
-   Terminals are the characters that make up the Final Codes
-   ![[Pasted image 20201219195057.png]]
-   ^1608044440405

### Non Terminal Symbol #card
-   Non terminals are the place holder of [[CFG ( Context Free Grammer )#^bc2370]]  ^0c9bd3
-   Non terminal symbols are those symbols which can be replaced.
-   Â A non-terminal called the left side of the production, an arrow, and a sequence of tokens and/or on- terminals
-   We can use [[CFG ( Context Free Grammer )#^0c9bd3]] to generate different patterns of terminal symbol
-   ![[Pasted image 20201219195050.png]]
-
^1608393331700   ^1608044433908

## Start Symbol

-   Def:: the variable represents the language being defined

ef :: There are finite set of production/rules that shows the recursive definition of a language
^1608275875845

# Formal Definition o^1608393332166
^1608555990609
^1608556025273
f CFG #card

-   The 4 components of G
-   ![[Pas^1608635657754
ted image 20201217134856.png]]

ram of `S â†’ aSb|Îµ` ? #card
![[Pasted image 20201217135118.png]]
^1608306157901

## **Context Free Grammars** (CFG) can be classified on the basis of following two properties:

1.  Based on number of strings it generates. #card
    -   If CFG is generating finite number of strings, then CFG is **Non-Recursive** (or Derivation)
    -   If CFG can generate infinite number ^1608393333036
of strings then the grammar is said to be **Recursive** grammar

-   If there is only 1 derivation tree then the CFG is unambiguous.
    -   If there are more than 1 derivation tree, then the CFG is [ambiguous](htt^1608393333428
ps://www.geeksforgeeks.org/ambiguous-grammar/).

ence of grammar rule applications that transform the start symbol into the string.<iframe src="https://www.youtube.com/embed/u4-rpIlV9NI" class="resize-vertical" style="height: 543px;"></iframe>
^1608306158734

<!--ignore-->

### Representation Technique

-   **Root vertex** âˆ’ Must be labeled by the **start** symbol.
-   **Vertex** âˆ’ Labeled by a **non-terminal** symbol.
-   **Leaves** âˆ’ Labeled by a **terminal** symbol or Îµ.

If S â†’ x<sub>1</sub>x<sub>2</sub> â€¦â€¦ x<sub>n</sub> is a production rule in a CFG, then the parse tree / derivation tree will be as follows âˆ’

![https://www.tutorialspoint.com/automata_theory/images/derivation_tree.jpg](https://www.tutorialspoint.com/automata_theory/images/derivation_tree.jpg)

#### There are two different approaches to draw a derivation tree âˆ’ #card

Top down approach and bottom down approach
^1608306159104

-   **Top-down Approach âˆ’**  #card
    -   Starts with the starting symbol **S**
    -   Goes down t^1608393333818
o tree leaves using productions

the root which is the starti^1608393334214
ng symbol **S**

^1608306159861
on tree is a sub-tree of a derivation tree/parse tree such that either all of its children are in the sub-tree or none of them are in the sub-tree. Also it is a string
^1608392446619

##### Example

If in any CFG the productions are âˆ’ `S â†’ AB, A â†’ aaA | Îµ, B â†’ Bb| Îµ`the partial derivation tree can be the following âˆ’ #card
![](https://www.tutorialspoint.com/automata_theory/images/sentential_form_and_partial_derivation_tree.jpg)
(There can be more trees to be reproduce this is just an example)
^1608392447030

#### Sentential Form

def::If a [[CFG ( Context Free Grammer )#^805ff3]] tree contains the root S, it is called a **sentential form**. The above sub-tree is also in sentential form. Also sentential form is a string
^1608392447444

## Ambiguous Grammar

Def:: A grammar said to be Ambiguous if there exists two or more derivation tree for a String w (that mean more then two left derivation tree)
^1608392447853

### Removing Ambiguity
Ambiguity may be removed by using the following methods #card 
![](https://www.gatevidyalay.com/wp-content/uploads/2018/08/Methods-to-Convert-Ambiguous-Grammar-into-Unambiguous-Grammar.png "Methods to Convert Ambiguous Grammar into Unambiguous Grammar")
- By fixing grammer
- By adding grouping rules
- By using semantics and choosing the parse that makes the most sense
- by adding the precedence rules or other context sensitive parsing rules

#### Removing Ambiguity By Precedence and Associativity rules
An ambiguous grammar may be converted into an unambiguous grammar by implementing #card 
- Precedence Constraints
- Associativity Constraints

These constraints are implemented using the following rules-

### **Rule-01:**

The precedence constraint is implemented using the following rules-

- The level at which the production is present defines the priority of the operator contained in it.
- The higher the level of the production, the lower the priority of operator.
- The lower the level of the production, the higher the priority of operator.

### **Rule-02:** ensure Associativity

The associativity constraint is implemented using the following rules- #card
- we need to *transform* grammer **left recursive**. Which means at the production *the head and the first variable of the leave must be the same*
- If the operator is right associative, induce right recursion in its production.
